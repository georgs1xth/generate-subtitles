script.
  const updateSelection = option => {
    const selectedValueEl = option.closest('.wrapper').querySelector('.select-value');
    const selectedOption = option.closest('.wrapper').querySelector('.selected');
    selectedOption.classList.remove('selected');
    option.classList.add('selected');
    selectedValueEl.textContent = option.textContent;
    selectedValueEl.dataset.value = option.dataset.value;
  }

  const handleSelectionButtonClick = evt => {
    const selectWrapper = evt.target.closest('.wrapper');
    const input = selectWrapper.querySelector('.search input');
    selectWrapper.classList.toggle('active');
    if (selectWrapper.classList.contains('active')) {
      input.focus();
      input.select();
      selectWrapper.querySelector('.selected')?.scrollIntoView({block: 'center', behavior: 'smooth'});
    } else {
      if (evt.target.id === 'translationSelect') {
        const langDisplay = evt.target.querySelector('.select-value');
        const selectedOptions = Array.from(selectWrapper.querySelectorAll('.selected'));
        langDisplay.textContent = selectedOptions.map(opt => opt.textContent).join(', ');
      }
      selectWrapper.querySelector('.select-btn').focus(); // BUG: doesn't focus

    }
  }

  const handleOptionClick = evt => {
    const option = evt.target;
    const selectWrapper = option.closest('.wrapper');
    const transSelector = selectWrapper.querySelector('#translationSelect');
    if (transSelector) {
      const checkbox = option.querySelector(`input[type='checkbox']`);
      if (checkbox) {
        checkbox.checked = !checkbox?.checked;
        const option = checkbox.closest('.option');
        checkbox.checked
        ? option.classList.add('selected')
        : option.classList.remove('selected');
      }
    } else {
      updateSelection(option);
      selectWrapper.classList.remove('active');
      selectWrapper.querySelector('.select-btn').focus();
    }
  }

  const handleSelectionShortcuts = evt => {
    const key = evt.key;
    ['ArrowDown', 'ArrowUp', 'Enter', 'Escape'].includes(key) && evt.preventDefault();

    const selectionContent = evt.target.closest('form .content');
    const focusedOption = document.activeElement.closest('.option');
    const focusedInput = document.activeElement.closest('input[type="search"]');

    const keysMap = [
      {command: /ArrowDown/, action: () => {
        //- focusedInput ? getNextVisibleSibling(selectionContent.querySelector('.selected'))?.focus()
        //- :
        // if there is a focused option, focus the next one, else focus the first one
        (getNextVisibleSibling(focusedOption) ??
        getFirstVisibleSibling(selectionContent.querySelector('.options')))
        .focus();
      }},

      {command: /ArrowUp/, action: () => {
        (getPreviousVisibleSibling(focusedOption) ??
        getLastVisibleSibling(selectionContent.querySelector('.options')))
        .focus();
      }},

      {command: /Enter/, action: () => focusedOption?.click()},
      
      {command: /Escape/, action: () => selectionContent.closest('.wrapper').classList.remove('active')},

      {command: /[a-z]/i, action: () => {
        selectionContent.querySelector(`input[type='search']`).focus();
      }},
    ];

    keysMap.find(({command}) => command.test(key))?.action();
  }

  const handleSelectionInput = evt => {
    l('handleSelectionInput');
    const input = evt.target;
    const options = Array.from(input.closest('.content').querySelectorAll('.option'));
    if (input.getAttribute('type') === 'checkbox') {
      const option = input.closest('.option');
      input.checked
      ? option.classList.add('selected')
      : option.classList.remove('selected');
    } else if (input.getAttribute('type') === 'search') {
      const selectButton = input.closest('.wrapper').querySelector('.select-btn');
      selectButton.id === 'languageSelect' && options.shift();
      const filteredOptions = filterOptions(options, input.value);

      options.forEach(option => {
        filteredOptions.includes(option)
        ? option.classList.remove('hidden')
        : option.classList.add('hidden');
      });
    }
  }